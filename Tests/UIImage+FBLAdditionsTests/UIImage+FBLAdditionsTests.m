/**
 Copyright 2018 Google Inc. All rights reserved.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at:

 http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
 */

#import "UIImage+FBLAdditions.h"

#import <XCTest/XCTest.h>

#import "UIImage+FBLAdditionsTestHelpers.h"

static NSString *const FBLPNGFileExtension = @"png";

@interface UIImageFBLAdditionsTests : XCTestCase
@end

@implementation UIImageFBLAdditionsTests

- (void)testFBLDrawImageIsLikeUIImageDrawInRect {
  /**
   This test exercises the same verification of FBLDrawImageWithOrientation for several sizes and
   scales. Each call to checkFBLDrawImageWithOrientationUsingWidth:height:scale: generates an image
   with the given pixel size and UIImages with every possible orientation and the given scale, and
   then confirms that the pixels generated by drawing that image with drawInRect (after flipping the
   coordinate system vertically) are identical to the pixels generated by using
   FBLDrawImageWithOrientation.
   */
  for (size_t width = 1; width < 8; ++width) {
    for (size_t height = 1; height < 8; ++height) {
      for (CGFloat scale = 0.1; scale <= 3.0; scale += 0.1) {
        [self checkFBLDrawImageWithOrientationUsingWidth:width height:height scale:scale];
      }
    }
  }
}

- (void)testFBLRotatedByDegrees {
  NSDictionary<NSString *, NSNumber *> *nameOfExpectationImageToRotationDegrees =
      @{ @"small" : @(0),
         @"small90" : @(90),
         @"smallMinus90" : @(-90),
         @"small180" : @(180) };

  NSBundle *bundle = [NSBundle bundleForClass:[self class]];
  NSString *originalPath = [bundle pathForResource:@"small" ofType:FBLPNGFileExtension];
  UIImage *originalImage = [[UIImage alloc] initWithContentsOfFile:originalPath];
  for (NSString *imageName in [nameOfExpectationImageToRotationDegrees allKeys]) {
    NSString *expectationImagePath = [bundle pathForResource:imageName ofType:FBLPNGFileExtension];
    UIImage *expectationImage = [UIImage imageWithContentsOfFile:expectationImagePath];
    CGFloat const degrees = [nameOfExpectationImageToRotationDegrees[imageName] doubleValue];
    UIImage *resultImage = [originalImage fbl_rotatedByDegrees:degrees];
    XCTAssertTrue(FBLTestImagesAreIdentical(resultImage, expectationImage));
  }
}

// This test case also tests horizontal and vertical image flipping as part of orientation change.
- (void)testFBLOrientedUp {
  NSDictionary<NSString *, NSNumber *> *expectedImageToOrientationDict = @{
    @"small" : @(UIImageOrientationUp),
    @"small90" : @(UIImageOrientationRight),
    @"smallMinus90" : @(UIImageOrientationLeft),
    @"small180" : @(UIImageOrientationDown),
    @"smallFlippedHorizontally" : @(UIImageOrientationUpMirrored),
    @"smallFlippedVertically" : @(UIImageOrientationLeftMirrored),
    @"small180FlippedHorizontally" : @(UIImageOrientationDownMirrored),
  };
  NSBundle *bundle = [NSBundle bundleForClass:[self class]];
  NSString *expectedImagePath = [bundle pathForResource:@"small" ofType:FBLPNGFileExtension];
  UIImage *expectedImage = [[UIImage alloc] initWithContentsOfFile:expectedImagePath];
  [expectedImageToOrientationDict
      enumerateKeysAndObjectsUsingBlock:^(NSString *imageName, NSNumber *orientation,
                                          BOOL *__unused _) {
        NSString *testImagePath = [bundle pathForResource:imageName ofType:FBLPNGFileExtension];
        UIImage *testImage = [UIImage imageWithContentsOfFile:testImagePath];
        testImage = [UIImage imageWithCGImage:testImage.CGImage
                                        scale:testImage.scale
                                  orientation:orientation.integerValue];
        testImage = [testImage fbl_orientedUp];
        XCTAssertTrue(FBLTestImagesAreIdentical(testImage, expectedImage));
        XCTAssertEqual(testImage.imageOrientation, UIImageOrientationUp);
      }];
}

#pragma mark - Helpers

/**
 Generates a pixel buffer with the given width and height, and instantiates several UIImages using
 that pixel buffer. One UIImage for each possible UIImageOrientation.
 Then draws each of those UIImages into a pixel buffer using -[UIImage drawInRect:], and into
 a separate pixel buffer using FBLDrawImageWithOrientation, and confirms that the output buffers
 are exactly the same.
 */
- (void)checkFBLDrawImageWithOrientationUsingWidth:(size_t)width
                                            height:(size_t)height
                                             scale:(CGFloat)scale {
  FBLTestRGBAColor *pixelBuffer = FBLTestCreateASCIISequencePixelBuffer(width, height);
  CGColorSpaceRef deviceRGB = CGColorSpaceCreateDeviceRGB();
  CGContextRef bitmapContext =
      CGBitmapContextCreate(pixelBuffer, width, height, 8, sizeof(FBLTestRGBAColor) * width,
                            deviceRGB, kCGBitmapAlphaInfoMask & kCGImageAlphaPremultipliedLast);
  CGImageRef imageRef = CGBitmapContextCreateImage(bitmapContext);
  CGColorSpaceRelease(deviceRGB);
  free(pixelBuffer);

  for (UIImageOrientation orientation = UIImageOrientationUp;
       orientation <= UIImageOrientationRightMirrored; orientation++) {
    UIImage *testImage = [UIImage imageWithCGImage:imageRef scale:scale orientation:orientation];
    CGSize const testImageSize = FBLSizeIntegral(testImage.size);
    size_t const testImagePixelWidth = testImageSize.width;
    size_t const testImagePixelHeight = testImageSize.height;
    size_t const testImagePixelBufferSize =
        sizeof(FBLTestRGBAColor) * testImagePixelWidth * testImagePixelHeight;

    // Draw the testImage using drawInRect.
    FBLTestRGBAColor *drawInRectPixelBuffer = (FBLTestRGBAColor *)malloc(testImagePixelBufferSize);
    CGContextRef drawInRectContext =
        CGBitmapContextCreate(drawInRectPixelBuffer, testImagePixelWidth, testImagePixelHeight, 8,
                              sizeof(FBLTestRGBAColor) * testImagePixelWidth, deviceRGB,
                              kCGBitmapAlphaInfoMask & kCGImageAlphaPremultipliedLast);
    CGContextTranslateCTM(drawInRectContext, 0.0, testImagePixelHeight);
    CGContextScaleCTM(drawInRectContext, 1.0, -1.0);
    UIGraphicsPushContext(drawInRectContext);
    [testImage drawInRect:CGRectMake(0.0, 0.0, testImagePixelWidth, testImagePixelHeight)];
    UIGraphicsPopContext();

    // Draw the same testImage using pure CoreGraphics, transforming the context with FBLDrawImage.
    FBLTestRGBAColor *fblPixelBuffer = (FBLTestRGBAColor *)malloc(testImagePixelBufferSize);
    CGContextRef fblContext =
        CGBitmapContextCreate(fblPixelBuffer, testImagePixelWidth, testImagePixelHeight, 8,
                              sizeof(FBLTestRGBAColor) * testImagePixelWidth, deviceRGB,
                              kCGBitmapAlphaInfoMask & kCGImageAlphaPremultipliedLast);
    FBLDrawCGImageInCGContext(fblContext, testImage.CGImage, orientation, scale);

    // Confirm that the pixel buffers are exactly the same.
    int comparisonResult = memcmp(drawInRectPixelBuffer, fblPixelBuffer, testImagePixelBufferSize);
    if (comparisonResult != 0) {
      XCTFail(@"Unexpected difference in images!");
      XCTFail(@"drawInRect result:");
      FBLTestASCIIArtPrint(drawInRectPixelBuffer, testImagePixelWidth, testImagePixelHeight);
      XCTFail(@"FBLDrawCGImageInCGContext result:");
      FBLTestASCIIArtPrint(fblPixelBuffer, testImagePixelWidth, testImagePixelHeight);
    }
    XCTAssertEqual(comparisonResult, 0);
    CGContextRelease(drawInRectContext);
    free(drawInRectPixelBuffer);
    CGContextRelease(fblContext);
    free(fblPixelBuffer);
  }
  CGColorSpaceRelease(deviceRGB);
  CGImageRelease(imageRef);
}

@end
